# Phase 1 Implementation Plan: Foundation MVP

## Goal
Working CLI that can be installed globally with `pnpm install -g cjode` and supports `cjode chat` with cost tracking and conversation persistence.

## Success Criteria
- [ ] Can install globally with `pnpm install -g cjode`
- [ ] `cjode chat` starts interactive session 
- [ ] Basic file operations work (read, edit, list) 
- [ ] Conversation history persisted with Drizzle + SQLite
- [ ] GitHub Action smoke test passes with build dependencies
- [ ] EventBus architecture implemented with proper event listeners

## Not required for success, but enabling these in the future should be considered when doing any current stuff
- [ ]  with visible cost tracking

## Implementation Steps

### Step 1: Initialize Turborepo Monorepo
**Duration**: 1-2 hours

1. **Initialize workspace**
   ```bash
   cd /Users/cje/dev/cjode
   rm -rf temp_starter  # Clean slate
   pnpm create turbo@latest . --use-pnpm
   ```

2. **Configure root package.json**
   ```json
   {
     "name": "cjode",
     "private": true,
     "packageManager": "pnpm@8",
     "type": "module",
     "scripts": {
       "build": "turbo build",
       "dev": "turbo dev",
       "lint": "turbo lint",
       "test": "turbo test"
     }
   }
   ```

3. **Setup pnpm workspace**
   ```yaml
   # pnpm-workspace.yaml
   packages:
     - "packages/*"
     - "apps/*"
   ```

4. **Configure Turborepo**
   ```json
   {
     "$schema": "https://turbo.build/schema.json",
     "pipeline": {
       "build": {
         "dependsOn": ["^build"],
         "outputs": ["dist/**"]
       },
       "lint": {},
       "dev": {
         "cache": false,
         "persistent": true
       },
       "test": {}
     }
   }
   ```

5. **Root TypeScript config (composite)**
   ```json
   {
     "compilerOptions": {
       "target": "ES2022",
       "module": "ESNext",
       "moduleResolution": "Node",
       "strict": true,
       "esModuleInterop": true,
       "skipLibCheck": true,
       "forceConsistentCasingInFileNames": true,
       "composite": true,
       "declaration": true,
       "declarationMap": true
     },
     "references": [
       { "path": "./packages/core" },
       { "path": "./packages/state" },
       { "path": "./packages/cli" }
     ]
   }
   ```

**Deliverable**: Working turborepo structure with proper TypeScript references

### Step 2: Core Package - Agent Logic & EventBus
**Duration**: 4-6 hours

1. **Create package structure**
   ```bash
   mkdir -p packages/core/src/{agent,models,tools,protocol,types,observability}
   ```

2. **Package.json for core**
   ```json
   {
     "name": "@cjode/core",
     "version": "0.1.0",
     "type": "module",
     "main": "dist/index.js",
     "types": "dist/index.d.ts",
     "engines": {
       "node": ">=20.9.0"
     },
     "exports": {
       ".": "./dist/index.js",
       "./types": "./dist/types/index.js"
     },
     "scripts": {
       "build": "tsup",
       "dev": "tsup --watch"
     },
     "dependencies": {
       "@ai-sdk/anthropic": "^0.0.39",
       "ai": "^3.0.0",
       "uuid": "^9.0.0"
     },
     "devDependencies": {
       "tsup": "^8.0.0",
       "typescript": "^5.0.0",
       "@types/uuid": "^9.0.0"
     }
   }
   ```

3. **TypeScript config for core (composite)**
   ```json
   {
     "extends": "../../tsconfig.json",
     "compilerOptions": {
       "composite": true,
       "rootDir": "./src",
       "outDir": "./dist"
     },
     "include": ["src/**/*"],
     "references": []
   }
   ```

4. **EventBus implementation**
   ```typescript
   // packages/core/src/agent/event-bus.ts
   import { EventEmitter } from 'node:events';

   export interface AgentEvent {
     type: 'tool_call_start' | 'tool_call_end' | 'message_start' | 'message_chunk' | 'message_end' | 'model_call_complete' | 'message_persist';
     conversationId: string;
     timestamp: Date;
     data: any;
   }

   class AgentEventBus extends EventEmitter {
     emit(event: AgentEvent['type'], data: AgentEvent): boolean {
       return super.emit(event, data);
     }
   }

   export const eventBus = new AgentEventBus();
   ```

5. **ModelProvider interface with pricing**
   ```typescript
   // packages/core/src/models/base.ts
   export interface ModelProvider {
     name: string;
     maxTokens: number;
     pricing: {
       promptTokensPer1k: number;
       completionTokensPer1k: number;
     };
     call(messages: any[], options?: any): Promise<ModelResponse>;
   }

   export interface ModelResponse {
     content: string;
     usage: {
       promptTokens: number;
       completionTokens: number;
       totalTokens: number;
     };
     cost: number;
   }
   ```

6. **Token counting wrapper**
   ```typescript
   // packages/core/src/models/token-counter.ts
   import { eventBus } from '../agent/event-bus.js';
   
   export function withTokenCounting<T extends ModelProvider>(
     provider: T,
     conversationId: string
   ): T {
     return {
       ...provider,
       async call(messages: any[], options?: any) {
         const startTime = Date.now();
         const response = await provider.call(messages, options);
         
         const cost = calculateCost(response.usage, provider.pricing);
         
         eventBus.emit('model_call_complete', {
           type: 'model_call_complete',
           conversationId,
           timestamp: new Date(),
           data: {
             model: provider.name,
             usage: response.usage,
             cost,
             durationMs: Date.now() - startTime
           }
         });

         return { ...response, cost };
       }
     };
   }

   function calculateCost(usage: any, pricing: any): number {
     return (
       (usage.promptTokens / 1000) * pricing.promptTokensPer1k +
       (usage.completionTokens / 1000) * pricing.completionTokensPer1k
     );
   }
   ```

7. **AgentOrchestrator class**
   ```typescript
   // packages/core/src/agent/orchestrator.ts
   export class AgentOrchestrator {
     constructor(
       private model: ModelProvider,
       private tools: Record<string, any>,
       private conversationId: string
     ) {}

     async processMessage(input: string): Promise<string> {
       // Pure orchestration logic - no I/O
       // Delegates to model and tools
       // Emits events via eventBus
     }
   }
   ```

**Deliverable**: Core package with EventBus, ModelProvider interface, and token counting

### Step 3: State Package - Config, Database, Cost Tracking
**Duration**: 6-8 hours

1. **Create package structure**
   ```bash
   mkdir -p packages/state/src/{config,db,migrations,cost}
   ```

2. **Package.json for state**
   ```json
   {
     "name": "@cjode/state",
     "version": "0.1.0",
     "type": "module",
     "main": "dist/index.js",
     "engines": {
       "node": ">=20.9.0"
     },
     "exports": {
       ".": "./dist/index.js",
       "./config": "./dist/config/index.js"
     },
     "scripts": {
       "build": "tsup",
       "dev": "tsup --watch",
       "db:migrate": "drizzle-kit push",
       "db:studio": "drizzle-kit studio"
     },
     "dependencies": {
       "drizzle-orm": "^0.30.0",
       "better-sqlite3": "^9.0.0",
       "@types/better-sqlite3": "^7.6.0"
     },
     "devDependencies": {
       "drizzle-kit": "^0.20.0",
       "tsup": "^8.0.0",
       "typescript": "^5.0.0"
     }
   }
   ```

3. **XDG-compliant config paths**
   ```typescript
   // packages/state/src/config/paths.ts
   import { homedir } from 'node:os';
   import { join } from 'node:path';

   const platform = process.platform;
   const home = homedir();

   export const configPaths = {
     config: platform === 'win32' 
       ? join(home, 'AppData', 'Roaming', 'cjode')
       : join(home, '.config', 'cjode'),
     data: platform === 'win32'
       ? join(home, 'AppData', 'Local', 'cjode')
       : join(home, '.local', 'share', 'cjode'),
     cache: platform === 'win32'
       ? join(home, 'AppData', 'Local', 'cjode', 'cache')
       : join(home, '.cache', 'cjode')
   };
   ```

4. **Drizzle schema definition**
   ```typescript
   // packages/state/src/db/schema.ts
   import { sqliteTable, text, integer, real } from 'drizzle-orm/sqlite-core';

   export const conversations = sqliteTable('conversations', {
     id: text('id').primaryKey(),
     title: text('title'),
     createdAt: integer('created_at', { mode: 'timestamp' }),
     updatedAt: integer('updated_at', { mode: 'timestamp' })
   });

   export const messages = sqliteTable('messages', {
     id: text('id').primaryKey(),
     conversationId: text('conversation_id').references(() => conversations.id),
     role: text('role'),
     content: text('content'),
     createdAt: integer('created_at', { mode: 'timestamp' })
   });

   export const usage = sqliteTable('usage', {
     id: text('id').primaryKey(),
     conversationId: text('conversation_id').references(() => conversations.id),
     model: text('model'),
     promptTokens: integer('prompt_tokens'),
     completionTokens: integer('completion_tokens'),
     totalTokens: integer('total_tokens'),
     cost: real('cost'),
     timestamp: integer('timestamp', { mode: 'timestamp' })
   });
   ```

5. **Database client setup**
   ```typescript
   // packages/state/src/db/client.ts
   import Database from 'better-sqlite3';
   import { drizzle } from 'drizzle-orm/better-sqlite3';
   import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
   import { configPaths } from '../config/paths.js';
   import * as schema from './schema.js';

   const sqlite = new Database(join(configPaths.data, 'cjode.db'));
   export const db = drizzle(sqlite, { schema });

   // Auto-migrate on startup
   migrate(db, { migrationsFolder: './migrations' });
   ```

6. **Cost tracking utilities with EventBus integration**
   ```typescript
   // packages/state/src/cost/tracking.ts
   import crypto from 'node:crypto';
   import { db } from '../db/client.js';
   import { usage, messages } from '../db/schema.js';
   import type { AgentEvent } from '@cjode/core';

   export function registerCostRecorder(eventBus: any) {
     // Listen for model usage events
     eventBus.on('model_call_complete', async (event: AgentEvent) => {
       const { model, usage: usageData, cost } = event.data;
       await recordUsage({
         conversationId: event.conversationId,
         model,
         promptTokens: usageData.promptTokens,
         completionTokens: usageData.completionTokens,
         cost
       });
     });

     // Listen for message persistence events
     eventBus.on('message_persist', async (event: AgentEvent) => {
       const { role, content } = event.data;
       await db.insert(messages).values({
         id: crypto.randomUUID(),
         conversationId: event.conversationId,
         role,
         content,
         createdAt: new Date()
       });
     });
   }

   async function recordUsage(data: {
     conversationId: string;
     model: string;
     promptTokens: number;
     completionTokens: number;
     cost: number;
   }) {
     await db.insert(usage).values({
       id: crypto.randomUUID(),
       ...data,
       totalTokens: data.promptTokens + data.completionTokens,
       timestamp: new Date()
     });
   }

   export async function getUsageStats(timeframe?: string) {
     // SQL aggregation views for cost analytics
     return db.select().from(usage).orderBy(usage.timestamp);
   }
   ```

**Deliverable**: State package with Drizzle ORM, SQLite database, and cost tracking

### Step 4: CLI Package - Global Installation & Commands
**Duration**: 4-6 hours

1. **Create package structure**
   ```bash
   mkdir -p packages/cli/src/{commands,repl,smoke-tests}
   mkdir -p packages/cli/bin
   ```

2. **Package.json for CLI (with global bin)**
   ```json
   {
     "name": "cjode",
     "version": "0.1.0",
     "type": "module",
     "engines": {
       "node": ">=20.9.0"
     },
     "bin": {
       "cjode": "./bin/cjode.js"
     },
     "main": "dist/index.js",
     "exports": {
       ".": "./dist/index.js"
     },
     "scripts": {
       "build": "tsup",
       "dev": "tsup --watch"
     },
     "dependencies": {
       "@cjode/core": "^0.1.0",
       "@cjode/state": "^0.1.0",
       "commander": "^11.0.0",
       "chalk": "^5.0.0"
     },
     "devDependencies": {
       "tsup": "^8.0.0",
       "typescript": "^5.0.0"
     }
   }
   ```

3. **Global binary script**
   ```bash
   #!/usr/bin/env node
   // packages/cli/bin/cjode.js
   import '../dist/index.js';
   ```
   
   ```bash
   # Make executable
   chmod +x packages/cli/bin/cjode.js
   ```

4. **CLI entry point with Commander**
   ```typescript
   // packages/cli/src/index.ts
   import { program } from 'commander';
   import { chatCommand } from './commands/chat.js';

   program
     .name('cjode')
     .description('Agentic coding CLI')
     .version('0.1.0');

   program
     .command('chat')
     .description('Start interactive chat session')
     .option('--model <model>', 'Model to use', 'claude-sonnet-4')
     .action(chatCommand);

   program.parse();
   ```

5. **Chat command implementation**
   ```typescript
   // packages/cli/src/commands/chat.ts
   import crypto from 'node:crypto';
   import { AgentOrchestrator, eventBus } from '@cjode/core';
   import { registerCostRecorder } from '@cjode/state';
   import { createReadline } from '../repl/interactive.js';

   export async function chatCommand(options: { model?: string }) {
     console.log('ðŸ¤– Cjode Agent (Ctrl+C to exit)');
     
     // Setup cost tracking
     registerCostRecorder(eventBus);
     
     // Subscribe to cost events for real-time display
     eventBus.on('model_call_complete', (event) => {
       const { cost, usage } = event.data;
       console.log(`ðŸ’° Cost: $${cost.toFixed(4)} | Tokens: ${usage.totalTokens}`);
     });
     
     const rl = createReadline();
     const conversationId = crypto.randomUUID();
     
     // Initialize agent with cost tracking
     const agent = new AgentOrchestrator(/* ... */);
     
     while (true) {
       const input = await rl.question('You: ');
       if (!input.trim()) continue;
       
       // Emit message persistence event
       eventBus.emit('message_persist', {
         type: 'message_persist',
         conversationId,
         timestamp: new Date(),
         data: { role: 'user', content: input }
       });
       
       const response = await agent.processMessage(input);
       console.log(`Agent: ${response}`);
       
       // Persist agent response
       eventBus.emit('message_persist', {
         type: 'message_persist',
         conversationId,
         timestamp: new Date(),
         data: { role: 'assistant', content: response }
       });
     }
   }
   ```

6. **tsup configuration for ESM bundling**
   ```typescript
   // packages/cli/tsup.config.ts
   import { defineConfig } from 'tsup';

   export default defineConfig({
     entry: ['src/index.ts'],
     format: ['esm'],
     target: 'node20',
     clean: true,
     dts: true,
     external: ['@cjode/core', '@cjode/state']
   });
   ```

**Deliverable**: Globally installable CLI with chat command

### Step 5: Integration & Testing
**Duration**: 3-4 hours

1. **Move existing tools from temp_starter**
   - Extract and adapt read_file, list_files, edit_file tools
   - Update to use new EventBus architecture
   - Add to core/tools module

2. **Anthropic provider implementation**
   ```typescript
   // packages/core/src/models/anthropic.ts
   import { createAnthropic } from '@ai-sdk/anthropic';
   import type { ModelProvider } from './base.js';

   export function createAnthropicProvider(apiKey: string): ModelProvider {
     const anthropic = createAnthropic({ apiKey });
     
     return {
       name: 'claude-sonnet-4',
       maxTokens: 200000,
       pricing: {
         promptTokensPer1k: 0.003,
         completionTokensPer1k: 0.015
       },
       async call(messages, options) {
         // Implement using existing ai-sdk integration
       }
     };
   }
   ```

3. **GitHub Action for smoke testing**
   ```yaml
   # .github/workflows/smoke-test.yml
   name: Smoke Test
   on: [push, pull_request]
   
   jobs:
     test:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4
         - uses: pnpm/action-setup@v4
           with:
             version: 8.15.0
         - uses: actions/setup-node@v4
           with:
             node-version: 20
             cache: pnpm
         
         # Install build dependencies for better-sqlite3
         - run: sudo apt-get update && sudo apt-get install -y build-essential python3
         
         - run: pnpm install
         - run: pnpm build
         
         # Publish packages to local registry first
         - run: pnpm --filter="@cjode/core" publish --dry-run --no-git-checks
         - run: pnpm --filter="@cjode/state" publish --dry-run --no-git-checks
         
         - run: pnpm pack --filter=cjode
         - run: pnpm install -g cjode-*.tgz
         - run: cjode --version
         - run: echo "test message" | timeout 10 cjode chat || true
   ```

4. **Basic smoke test**
   ```typescript
   // packages/cli/src/smoke-tests/basic.test.ts
   import { execSync } from 'node:child_process';
   import { test, expect } from 'vitest';

   test('CLI version command works', () => {
     const output = execSync('cjode --version', { encoding: 'utf8' });
     expect(output).toMatch(/0\.1\.0/);
   });
   ```

**Deliverable**: Working end-to-end integration with smoke tests

### Step 6: Documentation & Polish
**Duration**: 2-3 hours

1. **Update README.md**
   - Installation instructions
   - Basic usage examples
   - Development setup

2. **Package READMEs**
   - Core package API documentation
   - State package configuration guide
   - CLI usage examples

3. **Environment setup**
   - .env.example file
   - Configuration validation
   - Error handling for missing API keys

## Implementation Timeline (Oracle-Adjusted)
- **Day 1**: Steps 1-2 (Turborepo setup + Core package)
- **Day 2-2.5**: Step 3 (State package with database - extended for Drizzle setup)
- **Day 3**: Steps 4-5 (CLI package + integration)
- **Day 4**: Step 6 (Testing, docs, polish)
- **Day 4.5**: Buffer for publish/test iteration and issue resolution

## Key Integration Points
1. **EventBus** connects all packages for real-time updates
2. **Token counting** happens in model provider wrappers
3. **Cost tracking** automatically records to database via events
4. **Configuration** managed through XDG-compliant paths
5. **TypeScript** composite project with proper references

## Risk Mitigation (Oracle-Enhanced)
- **Native dependencies**: Include post-install help for better-sqlite3, install build-essential in CI
- **ESM compatibility**: Target Node 20+, test with various Node versions
- **Global installation**: Verify bin script permissions, use proper semver dependencies vs workspace:*
- **Database migrations**: Auto-run migrations on CLI startup, test from empty to current schema  
- **API key validation**: Clear error messages for missing/invalid keys
- **EventBus integration**: Ensure all events have proper listeners before emitting
- **Package publishing**: Use changeset or coordinated versioning for multi-package releases

## Success Validation
After implementation, verify:
1. `pnpm install -g cjode` from published package works
2. `cjode --version` shows correct version  
3. `cjode chat` starts interactive session with visible cost display
4. File operations work (read, edit, list) via agent tools
5. Conversations and messages persist between sessions in SQLite
6. Cost tracking shows token usage and cost after each model call
7. EventBus properly connects all packages for real-time updates
8. GitHub Action passes all tests including native dependency builds
9. Database migrations run automatically on first startup

---

## Oracle Feedback Applied

### Critical Fixes Implemented:
âœ… **Fixed EventBus event types** - Added 'model_call_complete' and 'message_persist' to union  
âœ… **Added EventBus listeners** - registerCostRecorder() sets up cost/message persistence  
âœ… **Replaced workspace:\*** - Used proper semver (^0.1.0) for publishable dependencies  
âœ… **Added build dependencies** - Include build-essential + python3 for better-sqlite3  
âœ… **Added composite TypeScript configs** - Each package has composite: true  
âœ… **Added Node version constraints** - engines: {"node": ">=20.9.0"} in all packages  
âœ… **Made cost tracking visible** - CLI displays cost/token info after each model call  
âœ… **Added database migration automation** - Auto-run migrations via drizzle-kit push  
âœ… **Fixed imports** - Added crypto from 'node:crypto' for UUID generation  

### Architecture Improvements:
- Event-driven persistence (Core â†’ State via EventBus)
- Real-time cost display in CLI  
- Proper package boundaries with exports maps
- Automated migration system
- CI/CD with native dependency support

The plan is now technically validated and addresses all Oracle-identified risks.
